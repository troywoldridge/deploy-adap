"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@algolia+transporter@4.24.0";
exports.ids = ["vendor-chunks/@algolia+transporter@4.24.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@algolia+transporter@4.24.0/node_modules/@algolia/transporter/dist/transporter.esm.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@algolia+transporter@4.24.0/node_modules/@algolia/transporter/dist/transporter.esm.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CallEnum: () => (/* binding */ CallEnum),\n/* harmony export */   HostStatusEnum: () => (/* binding */ HostStatusEnum),\n/* harmony export */   createApiError: () => (/* binding */ createApiError),\n/* harmony export */   createDeserializationError: () => (/* binding */ createDeserializationError),\n/* harmony export */   createMappedRequestOptions: () => (/* binding */ createMappedRequestOptions),\n/* harmony export */   createRetryError: () => (/* binding */ createRetryError),\n/* harmony export */   createStatefulHost: () => (/* binding */ createStatefulHost),\n/* harmony export */   createStatelessHost: () => (/* binding */ createStatelessHost),\n/* harmony export */   createTransporter: () => (/* binding */ createTransporter),\n/* harmony export */   createUserAgent: () => (/* binding */ createUserAgent),\n/* harmony export */   deserializeFailure: () => (/* binding */ deserializeFailure),\n/* harmony export */   deserializeSuccess: () => (/* binding */ deserializeSuccess),\n/* harmony export */   isStatefulHostTimeouted: () => (/* binding */ isStatefulHostTimeouted),\n/* harmony export */   isStatefulHostUp: () => (/* binding */ isStatefulHostUp),\n/* harmony export */   serializeData: () => (/* binding */ serializeData),\n/* harmony export */   serializeHeaders: () => (/* binding */ serializeHeaders),\n/* harmony export */   serializeQueryParameters: () => (/* binding */ serializeQueryParameters),\n/* harmony export */   serializeUrl: () => (/* binding */ serializeUrl),\n/* harmony export */   stackFrameWithoutCredentials: () => (/* binding */ stackFrameWithoutCredentials),\n/* harmony export */   stackTraceWithoutCredentials: () => (/* binding */ stackTraceWithoutCredentials)\n/* harmony export */ });\n/* harmony import */ var _algolia_requester_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @algolia/requester-common */ \"(ssr)/./node_modules/.pnpm/@algolia+requester-common@4.24.0/node_modules/@algolia/requester-common/dist/requester-common.esm.js\");\n\n\nfunction createMappedRequestOptions(requestOptions, timeout) {\r\n    const options = requestOptions || {};\r\n    const data = options.data || {};\r\n    Object.keys(options).forEach(key => {\r\n        if (['timeout', 'headers', 'queryParameters', 'data', 'cacheable'].indexOf(key) === -1) {\r\n            data[key] = options[key]; // eslint-disable-line functional/immutable-data\r\n        }\r\n    });\r\n    return {\r\n        data: Object.entries(data).length > 0 ? data : undefined,\r\n        timeout: options.timeout || timeout,\r\n        headers: options.headers || {},\r\n        queryParameters: options.queryParameters || {},\r\n        cacheable: options.cacheable,\r\n    };\r\n}\n\nconst CallEnum = {\r\n    /**\r\n     * If the host is read only.\r\n     */\r\n    Read: 1,\r\n    /**\r\n     * If the host is write only.\r\n     */\r\n    Write: 2,\r\n    /**\r\n     * If the host is both read and write.\r\n     */\r\n    Any: 3,\r\n};\n\nconst HostStatusEnum = {\r\n    Up: 1,\r\n    Down: 2,\r\n    Timeouted: 3,\r\n};\n\n// By default, API Clients at Algolia have expiration delay\r\n// of 5 mins. In the JavaScript client, we have 2 mins.\r\nconst EXPIRATION_DELAY = 2 * 60 * 1000;\r\nfunction createStatefulHost(host, status = HostStatusEnum.Up) {\r\n    return {\r\n        ...host,\r\n        status,\r\n        lastUpdate: Date.now(),\r\n    };\r\n}\r\nfunction isStatefulHostUp(host) {\r\n    return host.status === HostStatusEnum.Up || Date.now() - host.lastUpdate > EXPIRATION_DELAY;\r\n}\r\nfunction isStatefulHostTimeouted(host) {\r\n    return (host.status === HostStatusEnum.Timeouted && Date.now() - host.lastUpdate <= EXPIRATION_DELAY);\r\n}\n\nfunction createStatelessHost(options) {\r\n    if (typeof options === 'string') {\r\n        return {\r\n            protocol: 'https',\r\n            url: options,\r\n            accept: CallEnum.Any,\r\n        };\r\n    }\r\n    return {\r\n        protocol: options.protocol || 'https',\r\n        url: options.url,\r\n        accept: options.accept || CallEnum.Any,\r\n    };\r\n}\n\nfunction createRetryableOptions(hostsCache, statelessHosts) {\r\n    return Promise.all(statelessHosts.map(statelessHost => {\r\n        return hostsCache.get(statelessHost, () => {\r\n            return Promise.resolve(createStatefulHost(statelessHost));\r\n        });\r\n    })).then(statefulHosts => {\r\n        const hostsUp = statefulHosts.filter(host => isStatefulHostUp(host));\r\n        const hostsTimeouted = statefulHosts.filter(host => isStatefulHostTimeouted(host));\r\n        /**\r\n         * Note, we put the hosts that previously timeouted on the end of the list.\r\n         */\r\n        const hostsAvailable = [...hostsUp, ...hostsTimeouted];\r\n        const statelessHostsAvailable = hostsAvailable.length > 0\r\n            ? hostsAvailable.map(host => createStatelessHost(host))\r\n            : statelessHosts;\r\n        return {\r\n            getTimeout(timeoutsCount, baseTimeout) {\r\n                /**\r\n                 * Imagine that you have 4 hosts, if timeouts will increase\r\n                 * on the following way: 1 (timeouted) > 4 (timeouted) > 5 (200)\r\n                 *\r\n                 * Note that, the very next request, we start from the previous timeout\r\n                 *\r\n                 *  5 (timeouted) > 6 (timeouted) > 7 ...\r\n                 *\r\n                 * This strategy may need to be reviewed, but is the strategy on the our\r\n                 * current v3 version.\r\n                 */\r\n                const timeoutMultiplier = hostsTimeouted.length === 0 && timeoutsCount === 0\r\n                    ? 1\r\n                    : hostsTimeouted.length + 3 + timeoutsCount;\r\n                return timeoutMultiplier * baseTimeout;\r\n            },\r\n            statelessHosts: statelessHostsAvailable,\r\n        };\r\n    });\r\n}\n\nconst isNetworkError = ({ isTimedOut, status }) => {\r\n    return !isTimedOut && ~~status === 0;\r\n};\r\nconst isRetryable = (response) => {\r\n    const status = response.status;\r\n    const isTimedOut = response.isTimedOut;\r\n    return (isTimedOut || isNetworkError(response) || (~~(status / 100) !== 2 && ~~(status / 100) !== 4));\r\n};\r\nconst isSuccess = ({ status }) => {\r\n    return ~~(status / 100) === 2;\r\n};\r\nconst retryDecision = (response, outcomes) => {\r\n    if (isRetryable(response)) {\r\n        return outcomes.onRetry(response);\r\n    }\r\n    if (isSuccess(response)) {\r\n        return outcomes.onSuccess(response);\r\n    }\r\n    return outcomes.onFail(response);\r\n};\n\nfunction retryableRequest(transporter, statelessHosts, request, requestOptions) {\r\n    const stackTrace = []; // eslint-disable-line functional/prefer-readonly-type\r\n    /**\r\n     * First we prepare the payload that do not depend from hosts.\r\n     */\r\n    const data = serializeData(request, requestOptions);\r\n    const headers = serializeHeaders(transporter, requestOptions);\r\n    const method = request.method;\r\n    // On `GET`, the data is proxied to query parameters.\r\n    const dataQueryParameters = request.method !== _algolia_requester_common__WEBPACK_IMPORTED_MODULE_0__.MethodEnum.Get\r\n        ? {}\r\n        : {\r\n            ...request.data,\r\n            ...requestOptions.data,\r\n        };\r\n    const queryParameters = {\r\n        'x-algolia-agent': transporter.userAgent.value,\r\n        ...transporter.queryParameters,\r\n        ...dataQueryParameters,\r\n        ...requestOptions.queryParameters,\r\n    };\r\n    let timeoutsCount = 0; // eslint-disable-line functional/no-let\r\n    const retry = (hosts, // eslint-disable-line functional/prefer-readonly-type\r\n    getTimeout) => {\r\n        /**\r\n         * We iterate on each host, until there is no host left.\r\n         */\r\n        const host = hosts.pop(); // eslint-disable-line functional/immutable-data\r\n        if (host === undefined) {\r\n            throw createRetryError(stackTraceWithoutCredentials(stackTrace));\r\n        }\r\n        const payload = {\r\n            data,\r\n            headers,\r\n            method,\r\n            url: serializeUrl(host, request.path, queryParameters),\r\n            connectTimeout: getTimeout(timeoutsCount, transporter.timeouts.connect),\r\n            responseTimeout: getTimeout(timeoutsCount, requestOptions.timeout),\r\n        };\r\n        /**\r\n         * The stackFrame is pushed to the stackTrace so we\r\n         * can have information about onRetry and onFailure\r\n         * decisions.\r\n         */\r\n        const pushToStackTrace = (response) => {\r\n            const stackFrame = {\r\n                request: payload,\r\n                response,\r\n                host,\r\n                triesLeft: hosts.length,\r\n            };\r\n            // eslint-disable-next-line functional/immutable-data\r\n            stackTrace.push(stackFrame);\r\n            return stackFrame;\r\n        };\r\n        const decisions = {\r\n            onSuccess: response => deserializeSuccess(response),\r\n            onRetry(response) {\r\n                const stackFrame = pushToStackTrace(response);\r\n                /**\r\n                 * If response is a timeout, we increaset the number of\r\n                 * timeouts so we can increase the timeout later.\r\n                 */\r\n                if (response.isTimedOut) {\r\n                    timeoutsCount++;\r\n                }\r\n                return Promise.all([\r\n                    /**\r\n                     * Failures are individually send the logger, allowing\r\n                     * the end user to debug / store stack frames even\r\n                     * when a retry error does not happen.\r\n                     */\r\n                    transporter.logger.info('Retryable failure', stackFrameWithoutCredentials(stackFrame)),\r\n                    /**\r\n                     * We also store the state of the host in failure cases. If the host, is\r\n                     * down it will remain down for the next 2 minutes. In a timeout situation,\r\n                     * this host will be added end of the list of hosts on the next request.\r\n                     */\r\n                    transporter.hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? HostStatusEnum.Timeouted : HostStatusEnum.Down)),\r\n                ]).then(() => retry(hosts, getTimeout));\r\n            },\r\n            onFail(response) {\r\n                pushToStackTrace(response);\r\n                throw deserializeFailure(response, stackTraceWithoutCredentials(stackTrace));\r\n            },\r\n        };\r\n        return transporter.requester.send(payload).then(response => {\r\n            return retryDecision(response, decisions);\r\n        });\r\n    };\r\n    /**\r\n     * Finally, for each retryable host perform request until we got a non\r\n     * retryable response. Some notes here:\r\n     *\r\n     * 1. The reverse here is applied so we can apply a `pop` later on => more performant.\r\n     * 2. We also get from the retryable options a timeout multiplier that is tailored\r\n     * for the current context.\r\n     */\r\n    return createRetryableOptions(transporter.hostsCache, statelessHosts).then(options => {\r\n        return retry([...options.statelessHosts].reverse(), options.getTimeout);\r\n    });\r\n}\n\nfunction createTransporter(options) {\r\n    const { hostsCache, logger, requester, requestsCache, responsesCache, timeouts, userAgent, hosts, queryParameters, headers, } = options;\r\n    const transporter = {\r\n        hostsCache,\r\n        logger,\r\n        requester,\r\n        requestsCache,\r\n        responsesCache,\r\n        timeouts,\r\n        userAgent,\r\n        headers,\r\n        queryParameters,\r\n        hosts: hosts.map(host => createStatelessHost(host)),\r\n        read(request, requestOptions) {\r\n            /**\r\n             * First, we compute the user request options. Now, keep in mind,\r\n             * that using request options the user is able to modified the intire\r\n             * payload of the request. Such as headers, query parameters, and others.\r\n             */\r\n            const mappedRequestOptions = createMappedRequestOptions(requestOptions, transporter.timeouts.read);\r\n            const createRetryableRequest = () => {\r\n                /**\r\n                 * Then, we prepare a function factory that contains the construction of\r\n                 * the retryable request. At this point, we may *not* perform the actual\r\n                 * request. But we want to have the function factory ready.\r\n                 */\r\n                return retryableRequest(transporter, transporter.hosts.filter(host => (host.accept & CallEnum.Read) !== 0), request, mappedRequestOptions);\r\n            };\r\n            /**\r\n             * Once we have the function factory ready, we need to determine of the\r\n             * request is \"cacheable\" - should be cached. Note that, once again,\r\n             * the user can force this option.\r\n             */\r\n            const cacheable = mappedRequestOptions.cacheable !== undefined\r\n                ? mappedRequestOptions.cacheable\r\n                : request.cacheable;\r\n            /**\r\n             * If is not \"cacheable\", we immediatly trigger the retryable request, no\r\n             * need to check cache implementations.\r\n             */\r\n            if (cacheable !== true) {\r\n                return createRetryableRequest();\r\n            }\r\n            /**\r\n             * If the request is \"cacheable\", we need to first compute the key to ask\r\n             * the cache implementations if this request is on progress or if the\r\n             * response already exists on the cache.\r\n             */\r\n            const key = {\r\n                request,\r\n                mappedRequestOptions,\r\n                transporter: {\r\n                    queryParameters: transporter.queryParameters,\r\n                    headers: transporter.headers,\r\n                },\r\n            };\r\n            /**\r\n             * With the computed key, we first ask the responses cache\r\n             * implemention if this request was been resolved before.\r\n             */\r\n            return transporter.responsesCache.get(key, () => {\r\n                /**\r\n                 * If the request has never resolved before, we actually ask if there\r\n                 * is a current request with the same key on progress.\r\n                 */\r\n                return transporter.requestsCache.get(key, () => {\r\n                    return (transporter.requestsCache\r\n                        /**\r\n                         * Finally, if there is no request in progress with the same key,\r\n                         * this `createRetryableRequest()` will actually trigger the\r\n                         * retryable request.\r\n                         */\r\n                        .set(key, createRetryableRequest())\r\n                        .then(response => Promise.all([transporter.requestsCache.delete(key), response]), err => Promise.all([transporter.requestsCache.delete(key), Promise.reject(err)]))\r\n                        .then(([_, response]) => response));\r\n                });\r\n            }, {\r\n                /**\r\n                 * Of course, once we get this response back from the server, we\r\n                 * tell response cache to actually store the received response\r\n                 * to be used later.\r\n                 */\r\n                miss: response => transporter.responsesCache.set(key, response),\r\n            });\r\n        },\r\n        write(request, requestOptions) {\r\n            /**\r\n             * On write requests, no cache mechanisms are applied, and we\r\n             * proxy the request immediately to the requester.\r\n             */\r\n            return retryableRequest(transporter, transporter.hosts.filter(host => (host.accept & CallEnum.Write) !== 0), request, createMappedRequestOptions(requestOptions, transporter.timeouts.write));\r\n        },\r\n    };\r\n    return transporter;\r\n}\n\nfunction createUserAgent(version) {\r\n    const userAgent = {\r\n        value: `Algolia for JavaScript (${version})`,\r\n        add(options) {\r\n            const addedUserAgent = `; ${options.segment}${options.version !== undefined ? ` (${options.version})` : ''}`;\r\n            if (userAgent.value.indexOf(addedUserAgent) === -1) {\r\n                // eslint-disable-next-line functional/immutable-data\r\n                userAgent.value = `${userAgent.value}${addedUserAgent}`;\r\n            }\r\n            return userAgent;\r\n        },\r\n    };\r\n    return userAgent;\r\n}\n\nfunction deserializeSuccess(response) {\r\n    // eslint-disable-next-line functional/no-try-statement\r\n    try {\r\n        return JSON.parse(response.content);\r\n    }\r\n    catch (e) {\r\n        throw createDeserializationError(e.message, response);\r\n    }\r\n}\r\nfunction deserializeFailure({ content, status }, stackFrame) {\r\n    // eslint-disable-next-line functional/no-let\r\n    let message = content;\r\n    // eslint-disable-next-line functional/no-try-statement\r\n    try {\r\n        message = JSON.parse(content).message;\r\n    }\r\n    catch (e) {\r\n        // ..\r\n    }\r\n    return createApiError(message, status, stackFrame);\r\n}\n\n// eslint-disable-next-line functional/prefer-readonly-type\r\nfunction encode(format, ...args) {\r\n    // eslint-disable-next-line functional/no-let\r\n    let i = 0;\r\n    return format.replace(/%s/g, () => encodeURIComponent(args[i++]));\r\n}\n\nfunction serializeUrl(host, path, queryParameters) {\r\n    const queryParametersAsString = serializeQueryParameters(queryParameters);\r\n    // eslint-disable-next-line functional/no-let\r\n    let url = `${host.protocol}://${host.url}/${path.charAt(0) === '/' ? path.substr(1) : path}`;\r\n    if (queryParametersAsString.length) {\r\n        url += `?${queryParametersAsString}`;\r\n    }\r\n    return url;\r\n}\r\nfunction serializeQueryParameters(parameters) {\r\n    const isObjectOrArray = (value) => Object.prototype.toString.call(value) === '[object Object]' ||\r\n        Object.prototype.toString.call(value) === '[object Array]';\r\n    return Object.keys(parameters)\r\n        .map(key => encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]))\r\n        .join('&');\r\n}\r\nfunction serializeData(request, requestOptions) {\r\n    if (request.method === _algolia_requester_common__WEBPACK_IMPORTED_MODULE_0__.MethodEnum.Get ||\r\n        (request.data === undefined && requestOptions.data === undefined)) {\r\n        return undefined;\r\n    }\r\n    const data = Array.isArray(request.data)\r\n        ? request.data\r\n        : { ...request.data, ...requestOptions.data };\r\n    return JSON.stringify(data);\r\n}\r\nfunction serializeHeaders(transporter, requestOptions) {\r\n    const headers = {\r\n        ...transporter.headers,\r\n        ...requestOptions.headers,\r\n    };\r\n    const serializedHeaders = {};\r\n    Object.keys(headers).forEach(header => {\r\n        const value = headers[header];\r\n        // @ts-ignore\r\n        // eslint-disable-next-line functional/immutable-data\r\n        serializedHeaders[header.toLowerCase()] = value;\r\n    });\r\n    return serializedHeaders;\r\n}\n\nfunction stackTraceWithoutCredentials(stackTrace) {\r\n    return stackTrace.map(stackFrame => stackFrameWithoutCredentials(stackFrame));\r\n}\r\nfunction stackFrameWithoutCredentials(stackFrame) {\r\n    const modifiedHeaders = stackFrame.request.headers['x-algolia-api-key']\r\n        ? { 'x-algolia-api-key': '*****' }\r\n        : {};\r\n    return {\r\n        ...stackFrame,\r\n        request: {\r\n            ...stackFrame.request,\r\n            headers: {\r\n                ...stackFrame.request.headers,\r\n                ...modifiedHeaders,\r\n            },\r\n        },\r\n    };\r\n}\n\nfunction createApiError(message, status, transporterStackTrace) {\r\n    return {\r\n        name: 'ApiError',\r\n        message,\r\n        status,\r\n        transporterStackTrace,\r\n    };\r\n}\n\nfunction createDeserializationError(message, response) {\r\n    return {\r\n        name: 'DeserializationError',\r\n        message,\r\n        response,\r\n    };\r\n}\n\nfunction createRetryError(transporterStackTrace) {\r\n    return {\r\n        name: 'RetryError',\r\n        message: 'Unreachable hosts - your application id may be incorrect. If the error persists, please reach out to the Algolia Support team: https://alg.li/support .',\r\n        transporterStackTrace,\r\n    };\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFsZ29saWErdHJhbnNwb3J0ZXJANC4yNC4wL25vZGVfbW9kdWxlcy9AYWxnb2xpYS90cmFuc3BvcnRlci9kaXN0L3RyYW5zcG9ydGVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpRUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxzSEFBc0g7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBLHNDQUFzQyxFQUFFLGdCQUFnQixFQUFFLHFDQUFxQyxnQkFBZ0IsUUFBUTtBQUN2SDtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQixFQUFFLGVBQWU7QUFDdEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYyxLQUFLLFNBQVMsR0FBRywrQ0FBK0M7QUFDL0Y7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtYSIsInNvdXJjZXMiOlsiL3Zhci93d3cvZGVwbG95LWFkYXAvc3JjL25vZGVfbW9kdWxlcy8ucG5wbS9AYWxnb2xpYSt0cmFuc3BvcnRlckA0LjI0LjAvbm9kZV9tb2R1bGVzL0BhbGdvbGlhL3RyYW5zcG9ydGVyL2Rpc3QvdHJhbnNwb3J0ZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1ldGhvZEVudW0gfSBmcm9tICdAYWxnb2xpYS9yZXF1ZXN0ZXItY29tbW9uJztcblxuZnVuY3Rpb24gY3JlYXRlTWFwcGVkUmVxdWVzdE9wdGlvbnMocmVxdWVzdE9wdGlvbnMsIHRpbWVvdXQpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSByZXF1ZXN0T3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zLmRhdGEgfHwge307XHJcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKFsndGltZW91dCcsICdoZWFkZXJzJywgJ3F1ZXJ5UGFyYW1ldGVycycsICdkYXRhJywgJ2NhY2hlYWJsZSddLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgZGF0YVtrZXldID0gb3B0aW9uc1trZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmVudHJpZXMoZGF0YSkubGVuZ3RoID4gMCA/IGRhdGEgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IHRpbWVvdXQsXHJcbiAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IHt9LFxyXG4gICAgICAgIHF1ZXJ5UGFyYW1ldGVyczogb3B0aW9ucy5xdWVyeVBhcmFtZXRlcnMgfHwge30sXHJcbiAgICAgICAgY2FjaGVhYmxlOiBvcHRpb25zLmNhY2hlYWJsZSxcclxuICAgIH07XHJcbn1cblxuY29uc3QgQ2FsbEVudW0gPSB7XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBob3N0IGlzIHJlYWQgb25seS5cclxuICAgICAqL1xyXG4gICAgUmVhZDogMSxcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGhvc3QgaXMgd3JpdGUgb25seS5cclxuICAgICAqL1xyXG4gICAgV3JpdGU6IDIsXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBob3N0IGlzIGJvdGggcmVhZCBhbmQgd3JpdGUuXHJcbiAgICAgKi9cclxuICAgIEFueTogMyxcclxufTtcblxuY29uc3QgSG9zdFN0YXR1c0VudW0gPSB7XHJcbiAgICBVcDogMSxcclxuICAgIERvd246IDIsXHJcbiAgICBUaW1lb3V0ZWQ6IDMsXHJcbn07XG5cbi8vIEJ5IGRlZmF1bHQsIEFQSSBDbGllbnRzIGF0IEFsZ29saWEgaGF2ZSBleHBpcmF0aW9uIGRlbGF5XHJcbi8vIG9mIDUgbWlucy4gSW4gdGhlIEphdmFTY3JpcHQgY2xpZW50LCB3ZSBoYXZlIDIgbWlucy5cclxuY29uc3QgRVhQSVJBVElPTl9ERUxBWSA9IDIgKiA2MCAqIDEwMDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlZnVsSG9zdChob3N0LCBzdGF0dXMgPSBIb3N0U3RhdHVzRW51bS5VcCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5ob3N0LFxyXG4gICAgICAgIHN0YXR1cyxcclxuICAgICAgICBsYXN0VXBkYXRlOiBEYXRlLm5vdygpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1N0YXRlZnVsSG9zdFVwKGhvc3QpIHtcclxuICAgIHJldHVybiBob3N0LnN0YXR1cyA9PT0gSG9zdFN0YXR1c0VudW0uVXAgfHwgRGF0ZS5ub3coKSAtIGhvc3QubGFzdFVwZGF0ZSA+IEVYUElSQVRJT05fREVMQVk7XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0ZWZ1bEhvc3RUaW1lb3V0ZWQoaG9zdCkge1xyXG4gICAgcmV0dXJuIChob3N0LnN0YXR1cyA9PT0gSG9zdFN0YXR1c0VudW0uVGltZW91dGVkICYmIERhdGUubm93KCkgLSBob3N0Lmxhc3RVcGRhdGUgPD0gRVhQSVJBVElPTl9ERUxBWSk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RhdGVsZXNzSG9zdChvcHRpb25zKSB7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvdG9jb2w6ICdodHRwcycsXHJcbiAgICAgICAgICAgIHVybDogb3B0aW9ucyxcclxuICAgICAgICAgICAgYWNjZXB0OiBDYWxsRW51bS5BbnksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvdG9jb2w6IG9wdGlvbnMucHJvdG9jb2wgfHwgJ2h0dHBzJyxcclxuICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxyXG4gICAgICAgIGFjY2VwdDogb3B0aW9ucy5hY2NlcHQgfHwgQ2FsbEVudW0uQW55LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXRyeWFibGVPcHRpb25zKGhvc3RzQ2FjaGUsIHN0YXRlbGVzc0hvc3RzKSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc3RhdGVsZXNzSG9zdHMubWFwKHN0YXRlbGVzc0hvc3QgPT4ge1xyXG4gICAgICAgIHJldHVybiBob3N0c0NhY2hlLmdldChzdGF0ZWxlc3NIb3N0LCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlU3RhdGVmdWxIb3N0KHN0YXRlbGVzc0hvc3QpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pKS50aGVuKHN0YXRlZnVsSG9zdHMgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhvc3RzVXAgPSBzdGF0ZWZ1bEhvc3RzLmZpbHRlcihob3N0ID0+IGlzU3RhdGVmdWxIb3N0VXAoaG9zdCkpO1xyXG4gICAgICAgIGNvbnN0IGhvc3RzVGltZW91dGVkID0gc3RhdGVmdWxIb3N0cy5maWx0ZXIoaG9zdCA9PiBpc1N0YXRlZnVsSG9zdFRpbWVvdXRlZChob3N0KSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTm90ZSwgd2UgcHV0IHRoZSBob3N0cyB0aGF0IHByZXZpb3VzbHkgdGltZW91dGVkIG9uIHRoZSBlbmQgb2YgdGhlIGxpc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgaG9zdHNBdmFpbGFibGUgPSBbLi4uaG9zdHNVcCwgLi4uaG9zdHNUaW1lb3V0ZWRdO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlbGVzc0hvc3RzQXZhaWxhYmxlID0gaG9zdHNBdmFpbGFibGUubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICA/IGhvc3RzQXZhaWxhYmxlLm1hcChob3N0ID0+IGNyZWF0ZVN0YXRlbGVzc0hvc3QoaG9zdCkpXHJcbiAgICAgICAgICAgIDogc3RhdGVsZXNzSG9zdHM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2V0VGltZW91dCh0aW1lb3V0c0NvdW50LCBiYXNlVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbWFnaW5lIHRoYXQgeW91IGhhdmUgNCBob3N0cywgaWYgdGltZW91dHMgd2lsbCBpbmNyZWFzZVxyXG4gICAgICAgICAgICAgICAgICogb24gdGhlIGZvbGxvd2luZyB3YXk6IDEgKHRpbWVvdXRlZCkgPiA0ICh0aW1lb3V0ZWQpID4gNSAoMjAwKVxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCwgdGhlIHZlcnkgbmV4dCByZXF1ZXN0LCB3ZSBzdGFydCBmcm9tIHRoZSBwcmV2aW91cyB0aW1lb3V0XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogIDUgKHRpbWVvdXRlZCkgPiA2ICh0aW1lb3V0ZWQpID4gNyAuLi5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIHN0cmF0ZWd5IG1heSBuZWVkIHRvIGJlIHJldmlld2VkLCBidXQgaXMgdGhlIHN0cmF0ZWd5IG9uIHRoZSBvdXJcclxuICAgICAgICAgICAgICAgICAqIGN1cnJlbnQgdjMgdmVyc2lvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dE11bHRpcGxpZXIgPSBob3N0c1RpbWVvdXRlZC5sZW5ndGggPT09IDAgJiYgdGltZW91dHNDb3VudCA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICAgID8gMVxyXG4gICAgICAgICAgICAgICAgICAgIDogaG9zdHNUaW1lb3V0ZWQubGVuZ3RoICsgMyArIHRpbWVvdXRzQ291bnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZW91dE11bHRpcGxpZXIgKiBiYXNlVGltZW91dDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3RhdGVsZXNzSG9zdHM6IHN0YXRlbGVzc0hvc3RzQXZhaWxhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxuXG5jb25zdCBpc05ldHdvcmtFcnJvciA9ICh7IGlzVGltZWRPdXQsIHN0YXR1cyB9KSA9PiB7XHJcbiAgICByZXR1cm4gIWlzVGltZWRPdXQgJiYgfn5zdGF0dXMgPT09IDA7XHJcbn07XHJcbmNvbnN0IGlzUmV0cnlhYmxlID0gKHJlc3BvbnNlKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XHJcbiAgICBjb25zdCBpc1RpbWVkT3V0ID0gcmVzcG9uc2UuaXNUaW1lZE91dDtcclxuICAgIHJldHVybiAoaXNUaW1lZE91dCB8fCBpc05ldHdvcmtFcnJvcihyZXNwb25zZSkgfHwgKH5+KHN0YXR1cyAvIDEwMCkgIT09IDIgJiYgfn4oc3RhdHVzIC8gMTAwKSAhPT0gNCkpO1xyXG59O1xyXG5jb25zdCBpc1N1Y2Nlc3MgPSAoeyBzdGF0dXMgfSkgPT4ge1xyXG4gICAgcmV0dXJuIH5+KHN0YXR1cyAvIDEwMCkgPT09IDI7XHJcbn07XHJcbmNvbnN0IHJldHJ5RGVjaXNpb24gPSAocmVzcG9uc2UsIG91dGNvbWVzKSA9PiB7XHJcbiAgICBpZiAoaXNSZXRyeWFibGUocmVzcG9uc2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dGNvbWVzLm9uUmV0cnkocmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU3VjY2VzcyhyZXNwb25zZSkpIHtcclxuICAgICAgICByZXR1cm4gb3V0Y29tZXMub25TdWNjZXNzKHJlc3BvbnNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRjb21lcy5vbkZhaWwocmVzcG9uc2UpO1xyXG59O1xuXG5mdW5jdGlvbiByZXRyeWFibGVSZXF1ZXN0KHRyYW5zcG9ydGVyLCBzdGF0ZWxlc3NIb3N0cywgcmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHN0YWNrVHJhY2UgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL3ByZWZlci1yZWFkb25seS10eXBlXHJcbiAgICAvKipcclxuICAgICAqIEZpcnN0IHdlIHByZXBhcmUgdGhlIHBheWxvYWQgdGhhdCBkbyBub3QgZGVwZW5kIGZyb20gaG9zdHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGRhdGEgPSBzZXJpYWxpemVEYXRhKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBzZXJpYWxpemVIZWFkZXJzKHRyYW5zcG9ydGVyLCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICBjb25zdCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcclxuICAgIC8vIE9uIGBHRVRgLCB0aGUgZGF0YSBpcyBwcm94aWVkIHRvIHF1ZXJ5IHBhcmFtZXRlcnMuXHJcbiAgICBjb25zdCBkYXRhUXVlcnlQYXJhbWV0ZXJzID0gcmVxdWVzdC5tZXRob2QgIT09IE1ldGhvZEVudW0uR2V0XHJcbiAgICAgICAgPyB7fVxyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICAuLi5yZXF1ZXN0LmRhdGEsXHJcbiAgICAgICAgICAgIC4uLnJlcXVlc3RPcHRpb25zLmRhdGEsXHJcbiAgICAgICAgfTtcclxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHtcclxuICAgICAgICAneC1hbGdvbGlhLWFnZW50JzogdHJhbnNwb3J0ZXIudXNlckFnZW50LnZhbHVlLFxyXG4gICAgICAgIC4uLnRyYW5zcG9ydGVyLnF1ZXJ5UGFyYW1ldGVycyxcclxuICAgICAgICAuLi5kYXRhUXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgIC4uLnJlcXVlc3RPcHRpb25zLnF1ZXJ5UGFyYW1ldGVycyxcclxuICAgIH07XHJcbiAgICBsZXQgdGltZW91dHNDb3VudCA9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIGNvbnN0IHJldHJ5ID0gKGhvc3RzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvcHJlZmVyLXJlYWRvbmx5LXR5cGVcclxuICAgIGdldFRpbWVvdXQpID0+IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXZSBpdGVyYXRlIG9uIGVhY2ggaG9zdCwgdW50aWwgdGhlcmUgaXMgbm8gaG9zdCBsZWZ0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGhvc3QgPSBob3N0cy5wb3AoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgaWYgKGhvc3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVSZXRyeUVycm9yKHN0YWNrVHJhY2VXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tUcmFjZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHVybDogc2VyaWFsaXplVXJsKGhvc3QsIHJlcXVlc3QucGF0aCwgcXVlcnlQYXJhbWV0ZXJzKSxcclxuICAgICAgICAgICAgY29ubmVjdFRpbWVvdXQ6IGdldFRpbWVvdXQodGltZW91dHNDb3VudCwgdHJhbnNwb3J0ZXIudGltZW91dHMuY29ubmVjdCksXHJcbiAgICAgICAgICAgIHJlc3BvbnNlVGltZW91dDogZ2V0VGltZW91dCh0aW1lb3V0c0NvdW50LCByZXF1ZXN0T3B0aW9ucy50aW1lb3V0KSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzdGFja0ZyYW1lIGlzIHB1c2hlZCB0byB0aGUgc3RhY2tUcmFjZSBzbyB3ZVxyXG4gICAgICAgICAqIGNhbiBoYXZlIGluZm9ybWF0aW9uIGFib3V0IG9uUmV0cnkgYW5kIG9uRmFpbHVyZVxyXG4gICAgICAgICAqIGRlY2lzaW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBwdXNoVG9TdGFja1RyYWNlID0gKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrRnJhbWUgPSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBwYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICBob3N0LFxyXG4gICAgICAgICAgICAgICAgdHJpZXNMZWZ0OiBob3N0cy5sZW5ndGgsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgIHN0YWNrVHJhY2UucHVzaChzdGFja0ZyYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrRnJhbWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBkZWNpc2lvbnMgPSB7XHJcbiAgICAgICAgICAgIG9uU3VjY2VzczogcmVzcG9uc2UgPT4gZGVzZXJpYWxpemVTdWNjZXNzKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgb25SZXRyeShyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2tGcmFtZSA9IHB1c2hUb1N0YWNrVHJhY2UocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJZiByZXNwb25zZSBpcyBhIHRpbWVvdXQsIHdlIGluY3JlYXNldCB0aGUgbnVtYmVyIG9mXHJcbiAgICAgICAgICAgICAgICAgKiB0aW1lb3V0cyBzbyB3ZSBjYW4gaW5jcmVhc2UgdGhlIHRpbWVvdXQgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5pc1RpbWVkT3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dHNDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBGYWlsdXJlcyBhcmUgaW5kaXZpZHVhbGx5IHNlbmQgdGhlIGxvZ2dlciwgYWxsb3dpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZW5kIHVzZXIgdG8gZGVidWcgLyBzdG9yZSBzdGFjayBmcmFtZXMgZXZlblxyXG4gICAgICAgICAgICAgICAgICAgICAqIHdoZW4gYSByZXRyeSBlcnJvciBkb2VzIG5vdCBoYXBwZW4uXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ZXIubG9nZ2VyLmluZm8oJ1JldHJ5YWJsZSBmYWlsdXJlJywgc3RhY2tGcmFtZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja0ZyYW1lKSksXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogV2UgYWxzbyBzdG9yZSB0aGUgc3RhdGUgb2YgdGhlIGhvc3QgaW4gZmFpbHVyZSBjYXNlcy4gSWYgdGhlIGhvc3QsIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICogZG93biBpdCB3aWxsIHJlbWFpbiBkb3duIGZvciB0aGUgbmV4dCAyIG1pbnV0ZXMuIEluIGEgdGltZW91dCBzaXR1YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICogdGhpcyBob3N0IHdpbGwgYmUgYWRkZWQgZW5kIG9mIHRoZSBsaXN0IG9mIGhvc3RzIG9uIHRoZSBuZXh0IHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ZXIuaG9zdHNDYWNoZS5zZXQoaG9zdCwgY3JlYXRlU3RhdGVmdWxIb3N0KGhvc3QsIHJlc3BvbnNlLmlzVGltZWRPdXQgPyBIb3N0U3RhdHVzRW51bS5UaW1lb3V0ZWQgOiBIb3N0U3RhdHVzRW51bS5Eb3duKSksXHJcbiAgICAgICAgICAgICAgICBdKS50aGVuKCgpID0+IHJldHJ5KGhvc3RzLCBnZXRUaW1lb3V0KSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRmFpbChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgcHVzaFRvU3RhY2tUcmFjZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBkZXNlcmlhbGl6ZUZhaWx1cmUocmVzcG9uc2UsIHN0YWNrVHJhY2VXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tUcmFjZSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydGVyLnJlcXVlc3Rlci5zZW5kKHBheWxvYWQpLnRoZW4ocmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0cnlEZWNpc2lvbihyZXNwb25zZSwgZGVjaXNpb25zKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZpbmFsbHksIGZvciBlYWNoIHJldHJ5YWJsZSBob3N0IHBlcmZvcm0gcmVxdWVzdCB1bnRpbCB3ZSBnb3QgYSBub25cclxuICAgICAqIHJldHJ5YWJsZSByZXNwb25zZS4gU29tZSBub3RlcyBoZXJlOlxyXG4gICAgICpcclxuICAgICAqIDEuIFRoZSByZXZlcnNlIGhlcmUgaXMgYXBwbGllZCBzbyB3ZSBjYW4gYXBwbHkgYSBgcG9wYCBsYXRlciBvbiA9PiBtb3JlIHBlcmZvcm1hbnQuXHJcbiAgICAgKiAyLiBXZSBhbHNvIGdldCBmcm9tIHRoZSByZXRyeWFibGUgb3B0aW9ucyBhIHRpbWVvdXQgbXVsdGlwbGllciB0aGF0IGlzIHRhaWxvcmVkXHJcbiAgICAgKiBmb3IgdGhlIGN1cnJlbnQgY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJldHJ5YWJsZU9wdGlvbnModHJhbnNwb3J0ZXIuaG9zdHNDYWNoZSwgc3RhdGVsZXNzSG9zdHMpLnRoZW4ob3B0aW9ucyA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHJldHJ5KFsuLi5vcHRpb25zLnN0YXRlbGVzc0hvc3RzXS5yZXZlcnNlKCksIG9wdGlvbnMuZ2V0VGltZW91dCk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc3BvcnRlcihvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IGhvc3RzQ2FjaGUsIGxvZ2dlciwgcmVxdWVzdGVyLCByZXF1ZXN0c0NhY2hlLCByZXNwb25zZXNDYWNoZSwgdGltZW91dHMsIHVzZXJBZ2VudCwgaG9zdHMsIHF1ZXJ5UGFyYW1ldGVycywgaGVhZGVycywgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCB0cmFuc3BvcnRlciA9IHtcclxuICAgICAgICBob3N0c0NhY2hlLFxyXG4gICAgICAgIGxvZ2dlcixcclxuICAgICAgICByZXF1ZXN0ZXIsXHJcbiAgICAgICAgcmVxdWVzdHNDYWNoZSxcclxuICAgICAgICByZXNwb25zZXNDYWNoZSxcclxuICAgICAgICB0aW1lb3V0cyxcclxuICAgICAgICB1c2VyQWdlbnQsXHJcbiAgICAgICAgaGVhZGVycyxcclxuICAgICAgICBxdWVyeVBhcmFtZXRlcnMsXHJcbiAgICAgICAgaG9zdHM6IGhvc3RzLm1hcChob3N0ID0+IGNyZWF0ZVN0YXRlbGVzc0hvc3QoaG9zdCkpLFxyXG4gICAgICAgIHJlYWQocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpcnN0LCB3ZSBjb21wdXRlIHRoZSB1c2VyIHJlcXVlc3Qgb3B0aW9ucy4gTm93LCBrZWVwIGluIG1pbmQsXHJcbiAgICAgICAgICAgICAqIHRoYXQgdXNpbmcgcmVxdWVzdCBvcHRpb25zIHRoZSB1c2VyIGlzIGFibGUgdG8gbW9kaWZpZWQgdGhlIGludGlyZVxyXG4gICAgICAgICAgICAgKiBwYXlsb2FkIG9mIHRoZSByZXF1ZXN0LiBTdWNoIGFzIGhlYWRlcnMsIHF1ZXJ5IHBhcmFtZXRlcnMsIGFuZCBvdGhlcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb25zdCBtYXBwZWRSZXF1ZXN0T3B0aW9ucyA9IGNyZWF0ZU1hcHBlZFJlcXVlc3RPcHRpb25zKHJlcXVlc3RPcHRpb25zLCB0cmFuc3BvcnRlci50aW1lb3V0cy5yZWFkKTtcclxuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmV0cnlhYmxlUmVxdWVzdCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlbiwgd2UgcHJlcGFyZSBhIGZ1bmN0aW9uIGZhY3RvcnkgdGhhdCBjb250YWlucyB0aGUgY29uc3RydWN0aW9uIG9mXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgcmV0cnlhYmxlIHJlcXVlc3QuIEF0IHRoaXMgcG9pbnQsIHdlIG1heSAqbm90KiBwZXJmb3JtIHRoZSBhY3R1YWxcclxuICAgICAgICAgICAgICAgICAqIHJlcXVlc3QuIEJ1dCB3ZSB3YW50IHRvIGhhdmUgdGhlIGZ1bmN0aW9uIGZhY3RvcnkgcmVhZHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXRyeWFibGVSZXF1ZXN0KHRyYW5zcG9ydGVyLCB0cmFuc3BvcnRlci5ob3N0cy5maWx0ZXIoaG9zdCA9PiAoaG9zdC5hY2NlcHQgJiBDYWxsRW51bS5SZWFkKSAhPT0gMCksIHJlcXVlc3QsIG1hcHBlZFJlcXVlc3RPcHRpb25zKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9uY2Ugd2UgaGF2ZSB0aGUgZnVuY3Rpb24gZmFjdG9yeSByZWFkeSwgd2UgbmVlZCB0byBkZXRlcm1pbmUgb2YgdGhlXHJcbiAgICAgICAgICAgICAqIHJlcXVlc3QgaXMgXCJjYWNoZWFibGVcIiAtIHNob3VsZCBiZSBjYWNoZWQuIE5vdGUgdGhhdCwgb25jZSBhZ2FpbixcclxuICAgICAgICAgICAgICogdGhlIHVzZXIgY2FuIGZvcmNlIHRoaXMgb3B0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgY2FjaGVhYmxlID0gbWFwcGVkUmVxdWVzdE9wdGlvbnMuY2FjaGVhYmxlICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gbWFwcGVkUmVxdWVzdE9wdGlvbnMuY2FjaGVhYmxlXHJcbiAgICAgICAgICAgICAgICA6IHJlcXVlc3QuY2FjaGVhYmxlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSWYgaXMgbm90IFwiY2FjaGVhYmxlXCIsIHdlIGltbWVkaWF0bHkgdHJpZ2dlciB0aGUgcmV0cnlhYmxlIHJlcXVlc3QsIG5vXHJcbiAgICAgICAgICAgICAqIG5lZWQgdG8gY2hlY2sgY2FjaGUgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKGNhY2hlYWJsZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJldHJ5YWJsZVJlcXVlc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSWYgdGhlIHJlcXVlc3QgaXMgXCJjYWNoZWFibGVcIiwgd2UgbmVlZCB0byBmaXJzdCBjb21wdXRlIHRoZSBrZXkgdG8gYXNrXHJcbiAgICAgICAgICAgICAqIHRoZSBjYWNoZSBpbXBsZW1lbnRhdGlvbnMgaWYgdGhpcyByZXF1ZXN0IGlzIG9uIHByb2dyZXNzIG9yIGlmIHRoZVxyXG4gICAgICAgICAgICAgKiByZXNwb25zZSBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgY2FjaGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgbWFwcGVkUmVxdWVzdE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyczogdHJhbnNwb3J0ZXIucXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRyYW5zcG9ydGVyLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2l0aCB0aGUgY29tcHV0ZWQga2V5LCB3ZSBmaXJzdCBhc2sgdGhlIHJlc3BvbnNlcyBjYWNoZVxyXG4gICAgICAgICAgICAgKiBpbXBsZW1lbnRpb24gaWYgdGhpcyByZXF1ZXN0IHdhcyBiZWVuIHJlc29sdmVkIGJlZm9yZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnRlci5yZXNwb25zZXNDYWNoZS5nZXQoa2V5LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIElmIHRoZSByZXF1ZXN0IGhhcyBuZXZlciByZXNvbHZlZCBiZWZvcmUsIHdlIGFjdHVhbGx5IGFzayBpZiB0aGVyZVxyXG4gICAgICAgICAgICAgICAgICogaXMgYSBjdXJyZW50IHJlcXVlc3Qgd2l0aCB0aGUgc2FtZSBrZXkgb24gcHJvZ3Jlc3MuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlLmdldChrZXksICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRyYW5zcG9ydGVyLnJlcXVlc3RzQ2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEZpbmFsbHksIGlmIHRoZXJlIGlzIG5vIHJlcXVlc3QgaW4gcHJvZ3Jlc3Mgd2l0aCB0aGUgc2FtZSBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoaXMgYGNyZWF0ZVJldHJ5YWJsZVJlcXVlc3QoKWAgd2lsbCBhY3R1YWxseSB0cmlnZ2VyIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiByZXRyeWFibGUgcmVxdWVzdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXQoa2V5LCBjcmVhdGVSZXRyeWFibGVSZXF1ZXN0KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IFByb21pc2UuYWxsKFt0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlLmRlbGV0ZShrZXkpLCByZXNwb25zZV0pLCBlcnIgPT4gUHJvbWlzZS5hbGwoW3RyYW5zcG9ydGVyLnJlcXVlc3RzQ2FjaGUuZGVsZXRlKGtleSksIFByb21pc2UucmVqZWN0KGVycildKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKFtfLCByZXNwb25zZV0pID0+IHJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBPZiBjb3Vyc2UsIG9uY2Ugd2UgZ2V0IHRoaXMgcmVzcG9uc2UgYmFjayBmcm9tIHRoZSBzZXJ2ZXIsIHdlXHJcbiAgICAgICAgICAgICAgICAgKiB0ZWxsIHJlc3BvbnNlIGNhY2hlIHRvIGFjdHVhbGx5IHN0b3JlIHRoZSByZWNlaXZlZCByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICogdG8gYmUgdXNlZCBsYXRlci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgbWlzczogcmVzcG9uc2UgPT4gdHJhbnNwb3J0ZXIucmVzcG9uc2VzQ2FjaGUuc2V0KGtleSwgcmVzcG9uc2UpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRlKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPbiB3cml0ZSByZXF1ZXN0cywgbm8gY2FjaGUgbWVjaGFuaXNtcyBhcmUgYXBwbGllZCwgYW5kIHdlXHJcbiAgICAgICAgICAgICAqIHByb3h5IHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5IHRvIHRoZSByZXF1ZXN0ZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlUmVxdWVzdCh0cmFuc3BvcnRlciwgdHJhbnNwb3J0ZXIuaG9zdHMuZmlsdGVyKGhvc3QgPT4gKGhvc3QuYWNjZXB0ICYgQ2FsbEVudW0uV3JpdGUpICE9PSAwKSwgcmVxdWVzdCwgY3JlYXRlTWFwcGVkUmVxdWVzdE9wdGlvbnMocmVxdWVzdE9wdGlvbnMsIHRyYW5zcG9ydGVyLnRpbWVvdXRzLndyaXRlKSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gdHJhbnNwb3J0ZXI7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXNlckFnZW50KHZlcnNpb24pIHtcclxuICAgIGNvbnN0IHVzZXJBZ2VudCA9IHtcclxuICAgICAgICB2YWx1ZTogYEFsZ29saWEgZm9yIEphdmFTY3JpcHQgKCR7dmVyc2lvbn0pYCxcclxuICAgICAgICBhZGQob3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRlZFVzZXJBZ2VudCA9IGA7ICR7b3B0aW9ucy5zZWdtZW50fSR7b3B0aW9ucy52ZXJzaW9uICE9PSB1bmRlZmluZWQgPyBgICgke29wdGlvbnMudmVyc2lvbn0pYCA6ICcnfWA7XHJcbiAgICAgICAgICAgIGlmICh1c2VyQWdlbnQudmFsdWUuaW5kZXhPZihhZGRlZFVzZXJBZ2VudCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgdXNlckFnZW50LnZhbHVlID0gYCR7dXNlckFnZW50LnZhbHVlfSR7YWRkZWRVc2VyQWdlbnR9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXNlckFnZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHVzZXJBZ2VudDtcclxufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN1Y2Nlc3MocmVzcG9uc2UpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLXRyeS1zdGF0ZW1lbnRcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UuY29udGVudCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZURlc2VyaWFsaXphdGlvbkVycm9yKGUubWVzc2FnZSwgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRmFpbHVyZSh7IGNvbnRlbnQsIHN0YXR1cyB9LCBzdGFja0ZyYW1lKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIGxldCBtZXNzYWdlID0gY29udGVudDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLXRyeS1zdGF0ZW1lbnRcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IEpTT04ucGFyc2UoY29udGVudCkubWVzc2FnZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gLi5cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVBcGlFcnJvcihtZXNzYWdlLCBzdGF0dXMsIHN0YWNrRnJhbWUpO1xyXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL3ByZWZlci1yZWFkb25seS10eXBlXHJcbmZ1bmN0aW9uIGVuY29kZShmb3JtYXQsIC4uLmFyZ3MpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCAoKSA9PiBlbmNvZGVVUklDb21wb25lbnQoYXJnc1tpKytdKSk7XHJcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplVXJsKGhvc3QsIHBhdGgsIHF1ZXJ5UGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzQXNTdHJpbmcgPSBzZXJpYWxpemVRdWVyeVBhcmFtZXRlcnMocXVlcnlQYXJhbWV0ZXJzKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgbGV0IHVybCA9IGAke2hvc3QucHJvdG9jb2x9Oi8vJHtob3N0LnVybH0vJHtwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRofWA7XHJcbiAgICBpZiAocXVlcnlQYXJhbWV0ZXJzQXNTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgdXJsICs9IGA/JHtxdWVyeVBhcmFtZXRlcnNBc1N0cmluZ31gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVRdWVyeVBhcmFtZXRlcnMocGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgaXNPYmplY3RPckFycmF5ID0gKHZhbHVlKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJyB8fFxyXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1ldGVycylcclxuICAgICAgICAubWFwKGtleSA9PiBlbmNvZGUoJyVzPSVzJywga2V5LCBpc09iamVjdE9yQXJyYXkocGFyYW1ldGVyc1trZXldKSA/IEpTT04uc3RyaW5naWZ5KHBhcmFtZXRlcnNba2V5XSkgOiBwYXJhbWV0ZXJzW2tleV0pKVxyXG4gICAgICAgIC5qb2luKCcmJyk7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplRGF0YShyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykge1xyXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBNZXRob2RFbnVtLkdldCB8fFxyXG4gICAgICAgIChyZXF1ZXN0LmRhdGEgPT09IHVuZGVmaW5lZCAmJiByZXF1ZXN0T3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5pc0FycmF5KHJlcXVlc3QuZGF0YSlcclxuICAgICAgICA/IHJlcXVlc3QuZGF0YVxyXG4gICAgICAgIDogeyAuLi5yZXF1ZXN0LmRhdGEsIC4uLnJlcXVlc3RPcHRpb25zLmRhdGEgfTtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVIZWFkZXJzKHRyYW5zcG9ydGVyLCByZXF1ZXN0T3B0aW9ucykge1xyXG4gICAgY29uc3QgaGVhZGVycyA9IHtcclxuICAgICAgICAuLi50cmFuc3BvcnRlci5oZWFkZXJzLFxyXG4gICAgICAgIC4uLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMsXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2VyaWFsaXplZEhlYWRlcnMgPSB7fTtcclxuICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goaGVhZGVyID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlcnNbaGVhZGVyXTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICBzZXJpYWxpemVkSGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRIZWFkZXJzO1xyXG59XG5cbmZ1bmN0aW9uIHN0YWNrVHJhY2VXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tUcmFjZSkge1xyXG4gICAgcmV0dXJuIHN0YWNrVHJhY2UubWFwKHN0YWNrRnJhbWUgPT4gc3RhY2tGcmFtZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja0ZyYW1lKSk7XHJcbn1cclxuZnVuY3Rpb24gc3RhY2tGcmFtZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja0ZyYW1lKSB7XHJcbiAgICBjb25zdCBtb2RpZmllZEhlYWRlcnMgPSBzdGFja0ZyYW1lLnJlcXVlc3QuaGVhZGVyc1sneC1hbGdvbGlhLWFwaS1rZXknXVxyXG4gICAgICAgID8geyAneC1hbGdvbGlhLWFwaS1rZXknOiAnKioqKionIH1cclxuICAgICAgICA6IHt9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5zdGFja0ZyYW1lLFxyXG4gICAgICAgIHJlcXVlc3Q6IHtcclxuICAgICAgICAgICAgLi4uc3RhY2tGcmFtZS5yZXF1ZXN0LFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5zdGFja0ZyYW1lLnJlcXVlc3QuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgIC4uLm1vZGlmaWVkSGVhZGVycyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVBcGlFcnJvcihtZXNzYWdlLCBzdGF0dXMsIHRyYW5zcG9ydGVyU3RhY2tUcmFjZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiAnQXBpRXJyb3InLFxyXG4gICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgIHRyYW5zcG9ydGVyU3RhY2tUcmFjZSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVzZXJpYWxpemF0aW9uRXJyb3IobWVzc2FnZSwgcmVzcG9uc2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogJ0Rlc2VyaWFsaXphdGlvbkVycm9yJyxcclxuICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgIHJlc3BvbnNlLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXRyeUVycm9yKHRyYW5zcG9ydGVyU3RhY2tUcmFjZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiAnUmV0cnlFcnJvcicsXHJcbiAgICAgICAgbWVzc2FnZTogJ1VucmVhY2hhYmxlIGhvc3RzIC0geW91ciBhcHBsaWNhdGlvbiBpZCBtYXkgYmUgaW5jb3JyZWN0LiBJZiB0aGUgZXJyb3IgcGVyc2lzdHMsIHBsZWFzZSByZWFjaCBvdXQgdG8gdGhlIEFsZ29saWEgU3VwcG9ydCB0ZWFtOiBodHRwczovL2FsZy5saS9zdXBwb3J0IC4nLFxyXG4gICAgICAgIHRyYW5zcG9ydGVyU3RhY2tUcmFjZSxcclxuICAgIH07XHJcbn1cblxuZXhwb3J0IHsgQ2FsbEVudW0sIEhvc3RTdGF0dXNFbnVtLCBjcmVhdGVBcGlFcnJvciwgY3JlYXRlRGVzZXJpYWxpemF0aW9uRXJyb3IsIGNyZWF0ZU1hcHBlZFJlcXVlc3RPcHRpb25zLCBjcmVhdGVSZXRyeUVycm9yLCBjcmVhdGVTdGF0ZWZ1bEhvc3QsIGNyZWF0ZVN0YXRlbGVzc0hvc3QsIGNyZWF0ZVRyYW5zcG9ydGVyLCBjcmVhdGVVc2VyQWdlbnQsIGRlc2VyaWFsaXplRmFpbHVyZSwgZGVzZXJpYWxpemVTdWNjZXNzLCBpc1N0YXRlZnVsSG9zdFRpbWVvdXRlZCwgaXNTdGF0ZWZ1bEhvc3RVcCwgc2VyaWFsaXplRGF0YSwgc2VyaWFsaXplSGVhZGVycywgc2VyaWFsaXplUXVlcnlQYXJhbWV0ZXJzLCBzZXJpYWxpemVVcmwsIHN0YWNrRnJhbWVXaXRob3V0Q3JlZGVudGlhbHMsIHN0YWNrVHJhY2VXaXRob3V0Q3JlZGVudGlhbHMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@algolia+transporter@4.24.0/node_modules/@algolia/transporter/dist/transporter.esm.js\n");

/***/ })

};
;